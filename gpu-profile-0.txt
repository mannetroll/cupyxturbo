 Checking CuPy...
OS                           : Windows-10-10.0.19045-SP0
Python Version               : 3.13.11
CuPy Version                 : 13.6.0
CuPy Platform                : NVIDIA CUDA
NumPy Version                : 2.4.0
SciPy Version                : 1.16.3
Cython Build Version         : 3.0.12
Cython Runtime Version       : None
CUDA Root                    : C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v13.1
nvcc PATH                    : C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v13.1\bin\nvcc.EXE
CUDA Build Version           : 13000
CUDA Driver Version          : 13010
CUDA Runtime Version         : 13000 (linked to CuPy) / 13010 (locally installed)
CUDA Extra Include Dirs      : []
cuBLAS Version               : (available)
cuFFT Version                : 12100
cuRAND Version               : 10401
cuSOLVER Version             : (12, 0, 7)
cuSPARSE Version             : (available)
NVRTC Version                : (13, 1)
Thrust Version               : 200800
CUB Build Version            : 200800
Jitify Build Version         : 1a0ca0e
cuDNN Build Version          : None
cuDNN Version                : None
NCCL Build Version           : None
NCCL Runtime Version         : None
cuTENSOR Version             : None
cuSPARSELt Build Version     : None
Device 0 Name                : NVIDIA GeForce RTX 3090
Device 0 Compute Capability  : 86
Device 0 PCI Bus ID          : 0000:01:00.0
 Checking CuPy...
OS                           : Windows-10-10.0.19045-SP0
Python Version               : 3.13.11
CuPy Version                 : 13.6.0
CuPy Platform                : NVIDIA CUDA
NumPy Version                : 2.4.0
SciPy Version                : 1.16.3
Cython Build Version         : 3.0.12
Cython Runtime Version       : None
CUDA Root                    : C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v13.1
nvcc PATH                    : C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v13.1\bin\nvcc.EXE
CUDA Build Version           : 13000
CUDA Driver Version          : 13010
CUDA Runtime Version         : 13000 (linked to CuPy) / 13010 (locally installed)
CUDA Extra Include Dirs      : []
cuBLAS Version               : (available)
cuFFT Version                : 12100
cuRAND Version               : 10401
cuSOLVER Version             : (12, 0, 7)
cuSPARSE Version             : (available)
NVRTC Version                : (13, 1)
Thrust Version               : 200800
CUB Build Version            : 200800
Jitify Build Version         : 1a0ca0e
cuDNN Build Version          : None
cuDNN Version                : None
NCCL Build Version           : None
NCCL Runtime Version         : None
cuTENSOR Version             : None
cuSPARSELt Build Version     : None
Device 0 Name                : NVIDIA GeForce RTX 3090
Device 0 Compute Capability  : 86
Device 0 PCI Bus ID          : 0000:01:00.0
--- RUN DNS ---
 N   = 1024
 Re  = 10000.0
 K0  = 10.0
 Steps = 10001
 CFL  = 0.75
 requested = gpu
 backend:  gpu
 workers (CPU): 5
FFT plan_mod: cupyx.scipy.fft
--- INITIALIZING SciPy/CuPy --- 2026-01-03 21:32
 N=1024, K0=10, Re=10000.0
Generate isotropic random spectrum...
z=0/1024
z=1000/1024
Compute averages A(1..7), E110, Q2, W2, VISC...
 N           =        1024
 Reynolds n. =       1e+04
 K0          =          10
 Energy      =      0.9968
 WiWi        =    100.0000
 Epsilon     =      0.0997
 a11         =     -0.0000
 e11         =     -0.0000
 Time scale  =           5
 Kolmogorov  =      0.0100
 Viscosity   =      0.0010
 dx/Kol.     =      0.6146
 2Pi/Nlamda  =     18.7245
 2Pi/Lux     =     22.2496
 2Pi/Luz     =     38.5380
 2Pi/Lwx     =     38.5380
 2Pi/Lwz     =     22.2496
 Deps.       =      0.0397
 Ceps2       =      1.9936
 E1          =      1.0000
 E3          =      1.0000
 PAO seed    =        1983
 PAO initialization OK. VISC=0.0009968169
 effective = gpu (xp = cupy)
 scipy.fft workers in-context = 1
 [NEXTDT INIT] CFLM=   666.0746 DT=  0.0003584 CN=  1.0000000
 Initial DT=  0.0003584 CN=  1.0000000
 ITERATION      1 T=0.0003584169 DT=0.00035843 CN=1.00004586
 ITERATION    100 T=0.0363059607 DT=0.00036914 CN=1.00038089
 ITERATION    200 T=0.0739690524 DT=0.00038470 CN=1.00043868
 ITERATION    300 T=0.1131380663 DT=0.00039448 CN=0.99997353
 ITERATION    400 T=0.1527099136 DT=0.00039850 CN=1.00021157
 ITERATION    500 T=0.1931656620 DT=0.00041252 CN=1.00045721
 ITERATION    600 T=0.2354712800 DT=0.00043027 CN=0.99958555
 ITERATION    700 T=0.2773100179 DT=0.00040781 CN=0.99957687
 ITERATION    800 T=0.3173500123 DT=0.00039403 CN=0.99972282
 ITERATION    900 T=0.3563232190 DT=0.00038625 CN=0.99986374
 ITERATION   1000 T=0.3947971147 DT=0.00038425 CN=1.00003019
 ITERATION   1100 T=0.4334098314 DT=0.00038939 CN=1.00023504
 ITERATION   1200 T=0.4724741281 DT=0.00038959 CN=0.99994650
 ITERATION   1300 T=0.5114274889 DT=0.00039034 CN=1.00007560
 ITERATION   1400 T=0.5507061433 DT=0.00039622 CN=1.00021553
 ITERATION   1500 T=0.5907756344 DT=0.00040269 CN=0.99997370
 ITERATION   1600 T=0.6310130901 DT=0.00040264 CN=1.00004336
 ITERATION   1700 T=0.6714249405 DT=0.00040624 CN=1.00013317
 ITERATION   1800 T=0.7123187910 DT=0.00040668 CN=0.99934614
 ITERATION   1900 T=0.7518143559 DT=0.00038451 CN=0.99955024
 ITERATION   2000 T=0.7895159609 DT=0.00037057 CN=0.99971288
 ITERATION   2100 T=0.8261403912 DT=0.00036261 CN=0.99982570
 ITERATION   2200 T=0.8621504388 DT=0.00035783 CN=0.99988400
 ITERATION   2300 T=0.8977089847 DT=0.00035306 CN=0.99984004
 ITERATION   2400 T=0.9326890169 DT=0.00034600 CN=0.99976085
 ITERATION   2500 T=0.9667848643 DT=0.00033503 CN=0.99964263
 ITERATION   2600 T=0.9997163080 DT=0.00032373 CN=0.99967784
 ITERATION   2700 T=1.0316033475 DT=0.00031427 CN=0.99974410
 ITERATION   2800 T=1.0626593838 DT=0.00030722 CN=0.99981208
 ITERATION   2900 T=1.0931484027 DT=0.00030302 CN=0.99990417
 ITERATION   3000 T=1.1233674130 DT=0.00030189 CN=1.00001135
 ITERATION   3100 T=1.1536329624 DT=0.00030397 CN=1.00011892
 ITERATION   3200 T=1.1842650009 DT=0.00030928 CN=1.00022750
 ITERATION   3300 T=1.2155870429 DT=0.00031777 CN=1.00032390
 ITERATION   3400 T=1.2479086549 DT=0.00032924 CN=1.00038391
 ITERATION   3500 T=1.2815038918 DT=0.00034316 CN=1.00043464
 ITERATION   3600 T=1.3165894593 DT=0.00035899 CN=1.00046524
 ITERATION   3700 T=1.3532987190 DT=0.00037524 CN=1.00041582
 ITERATION   3800 T=1.3915130606 DT=0.00038821 CN=1.00025797
 ITERATION   3900 T=1.4307473322 DT=0.00039592 CN=1.00015719
 ITERATION   4000 T=1.4706184560 DT=0.00040132 CN=1.00012309
 ITERATION   4100 T=1.5109607814 DT=0.00040519 CN=1.00006665
 ITERATION   4200 T=1.5515480291 DT=0.00040595 CN=0.99997232
 ITERATION   4300 T=1.5920532192 DT=0.00040381 CN=0.99993182
 ITERATION   4400 T=1.6322877352 DT=0.00040092 CN=0.99994009
 ITERATION   4500 T=1.6722815795 DT=0.00039924 CN=0.99997783
 ITERATION   4600 T=1.7122040317 DT=0.00039956 CN=1.00003320
 ITERATION   4700 T=1.7522641407 DT=0.00040202 CN=1.00008725
 ITERATION   4800 T=1.7926728899 DT=0.00040654 CN=1.00013274
 ITERATION   4900 T=1.8336316898 DT=0.00041298 CN=1.00017745
 ITERATION   5000 T=1.8753027421 DT=0.00042065 CN=1.00018516
 ITERATION   5100 T=1.9177567783 DT=0.00042845 CN=1.00018106
 ITERATION   5200 T=1.9609627323 DT=0.00043563 CN=1.00015788
 ITERATION   5300 T=2.0048622004 DT=0.00044238 CN=1.00015630
 ITERATION   5400 T=2.0494269016 DT=0.00044898 CN=1.00014193
 ITERATION   5500 T=2.0946479428 DT=0.00045549 CN=1.00014266
 ITERATION   5600 T=2.1405071666 DT=0.00046166 CN=1.00012578
 ITERATION   5700 T=2.1869399468 DT=0.00046682 CN=1.00009532
 ITERATION   5800 T=2.2332088396 DT=0.00045678 CN=0.99978474
 ITERATION   5900 T=2.2785039585 DT=0.00045012 CN=0.99992512
 ITERATION   6000 T=2.3234400827 DT=0.00044955 CN=1.00004560
 ITERATION   6100 T=2.3685974954 DT=0.00045467 CN=1.00018739
 ITERATION   6200 T=2.4145826289 DT=0.00046641 CN=1.00033086
 ITERATION   6300 T=2.4613646219 DT=0.00046746 CN=0.99997680
 ITERATION   6400 T=2.5080972331 DT=0.00046737 CN=1.00000656
 ITERATION   6500 T=2.5548624328 DT=0.00046803 CN=1.00001055
 ITERATION   6600 T=2.6017070422 DT=0.00046882 CN=1.00001192
 ITERATION   6700 T=2.6486011141 DT=0.00046887 CN=0.99998220
 ITERATION   6800 T=2.6954308597 DT=0.00046743 CN=0.99994669
 ITERATION   6900 T=2.7420327833 DT=0.00046434 CN=0.99992515
 ITERATION   7000 T=2.7882694438 DT=0.00046028 CN=0.99990950
 ITERATION   7100 T=2.8340965549 DT=0.00045630 CN=0.99992058
 ITERATION   7200 T=2.8795610351 DT=0.00045311 CN=0.99994034
 ITERATION   7300 T=2.9247535011 DT=0.00045086 CN=0.99995927
 ITERATION   7400 T=2.9697582258 DT=0.00044931 CN=0.99996879
 ITERATION   7500 T=3.0146252100 DT=0.00044803 CN=0.99997058
 ITERATION   7600 T=3.0593579805 DT=0.00044657 CN=0.99996576
 ITERATION   7700 T=3.1039415933 DT=0.00044513 CN=0.99997294
 ITERATION   7800 T=3.1484056489 DT=0.00044431 CN=0.99999371
 ITERATION   7900 T=3.1928521491 DT=0.00044493 CN=1.00003426
 ITERATION   8000 T=3.2374615651 DT=0.00044772 CN=1.00008860
 ITERATION   8100 T=3.2824848051 DT=0.00045331 CN=1.00015639
 ITERATION   8200 T=3.3282239637 DT=0.00046209 CN=1.00022305
 ITERATION   8300 T=3.3749991450 DT=0.00047403 CN=1.00028604
 ITERATION   8400 T=3.4231087664 DT=0.00048870 CN=1.00032249
 ITERATION   8500 T=3.4727849910 DT=0.00050521 CN=1.00034016
 ITERATION   8600 T=3.5241540712 DT=0.00052236 CN=1.00032541
 ITERATION   8700 T=3.5772227324 DT=0.00053906 CN=1.00030178
 ITERATION   8800 T=3.6316440763 DT=0.00054664 CN=1.00007567
 ITERATION   8900 T=3.6865473802 DT=0.00055191 CN=1.00011926
 ITERATION   9000 T=3.7414984674 DT=0.00054372 CN=0.99976722
 ITERATION   9100 T=3.7952121004 DT=0.00052988 CN=0.99972293
 ITERATION   9200 T=3.8474843907 DT=0.00051558 CN=0.99973190
 ITERATION   9300 T=3.8983834889 DT=0.00050251 CN=0.99975762
 ITERATION   9400 T=3.9480541751 DT=0.00049109 CN=0.99978751
 ITERATION   9500 T=3.9966765388 DT=0.00048161 CN=0.99982532
 ITERATION   9600 T=4.0444561475 DT=0.00047430 CN=0.99986933
 ITERATION   9700 T=4.0916218274 DT=0.00046940 CN=0.99992394
 ITERATION   9800 T=4.1384287551 DT=0.00046720 CN=0.99998642
 ITERATION   9900 T=4.1851637036 DT=0.00046804 CN=1.00004710
 ITERATION  10000 T=4.2321491352 DT=0.00047231 CN=1.00013265
 ITERATION  10001 T=4.2326214440 DT=0.00047237 CN=1.00013308
 Elapsed CPU time for 10001 steps (s) =  25.0129
 Final T= 4.23262  CN= 1.00013  DT=0.000472372
 FPS = 399.834
  C:\Users\tobbe\python\cupyxturbo\scipyturbo\turbo_simulator.py: % of time =  
                       100.00% (30.119s) out of 30.119s.                       
+-----------------------------------------------------------------------------+
|       |Time    |–––––– |–––––– |                                            |
| Line  |Python  |native |system |C:\Users\tobbe\python\cupyxturbo\scipyturb
 |
|-------+--------+-------+-------+--------------------------------------------|
|     1 |        |       |       |"""                                         |
|     2 |        |       |       |turbo_simulator.py â€” 2D Homogeneous Turbu |
|     3 |        |       |       |                                            |
|     4 |        |       |       |This is a structural port of dns_all.cu to  |
|     5 |        |       |       |                                            |
|     6 |        |       |       |Key ideas kept from the CUDA version:       |
|     7 |        |       |       |  â€¢ DnsState structure mirrors DnsDeviceS |
|     8 |        |       |       |  â€¢ UR (compact)  : shape (NZ, NX, 3)   â |
|     9 |        |       |       |  â€¢ UC (compact)  : shape (NZ, NK, 3)   â |
|    10 |        |       |       |  â€¢ UR_full (3/2) : shape (3, NZ_full, NX |
|    11 |        |       |       |  â€¢ UC_full (3/2) : shape (3, NZ_full, NK |
|    12 |        |       |       |  â€¢ om2, fnm1     : shape (NZ, NX_half) â |
|    13 |        |       |       |  â€¢ alfa[NX_half], gamma[NZ]           â€ |
|    14 |        |       |       |  â€¢ Time loop     : STEP2B â†’ STEP3 â†’  |
|    15 |        |       |       |                                            |
|    16 |        |       |       |Backends:                                   |
|    17 |        |       |       |  â€¢ CPU:  SciPy                           |
|    18 |        |       |       |  â€¢ GPU:  CuPy (if installed); same API u |
|    19 |        |       |       |                                            |
|    20 |        |       |       |This is now a faithful structural port of d |
|    21 |        |       |       |                                            |
|    22 |        |       |       |  â€¢ dnsCudaPaoHostInit  â†’ dns_pao_host_ |
|    23 |        |       |       |  â€¢ dnsCudaCalcom       â†’ dns_calcom_fr |
|    24 |        |       |       |  â€¢ dnsCudaStep2A/2B/3  â†’ dns_step2a /  |
|    25 |        |       |       |  â€¢ next_dt_gpu         â†’ next_dt       |
|    26 |        |       |       |                                            |
|    27 |        |       |       |The 3/2 de-aliasing, Crankâ€“Nicolson updat |
|    28 |        |       |       |formulas follow the CUDA kernels line-by-li |
|    29 |        |       |       |"""                                         |
|    30 |        |       |       |from contextlib import nullcontext          |
|    31 |        |       |       |import time                                 |
|    32 |        |       |       |import datetime as _dt                      |
|    33 |        |       |       |import math                                 |
|    34 |        |       |       |import sys                                  |
|    35 |        |       |       |from dataclasses import dataclass           |
|    36 |        |       |       |from typing import Literal                  |
|    37 |        |       |       |                                            |
|    38 |        |       |       |import numpy as _np                         |
|    39 |        |       |       |                                            |
|    40 |        |       |       |try:                                        |
|    41 |        |       |       |    print(" Checking CuPy...")              |
|    42 |        |       |       |    import cupy as _cp                      |
|    43 |        |       |       |    _cp.show_config()                       |
|    44 |        |       |       |except Exception:  # CuPy is optional       |
|    45 |        |       |       |    _cp = None                              |
|    46 |        |       |       |    print(" CuPy not installed")            |
|    47 |        |       |       |                                            |
|    48 |        |       |       |import numpy as np  # in addition to your e |
|    49 |        |       |       |                                            |
|    50 |        |       |       |# ========================================= |
|    51 |        |       |       |# ONLY FFT selection (CPU: scipy.fft, GPU:  |
|    52 |        |       |       |# ========================================= |
|    53 |        |       |       |try:                                        |
|    54 |        |       |       |    import scipy.fft as _spfft  # type: ign |
|    55 |        |       |       |except Exception:                           |
|    56 |        |       |       |    _spfft = None                           |
|    57 |        |       |       |                                            |
|    58 |        |       |       |try:                                        |
|    59 |        |       |       |    import cupyx.scipy.fft as _cpfft  # typ |
|    60 |        |       |       |except Exception:                           |
|    61 |        |       |       |    _cpfft = None                           |
|    62 |        |       |       |                                            |
|    63 |        |       |       |                                            |
|    64 |        |       |       |def _fft_mod_for_state(S: "DnsState"):      |
|    65 |        |       |       |    """                                     |
|    66 |        |       |       |    ONLY FFT selection:                     |
|    67 |        |       |       |      - CPU: scipy.fft                      |
|    68 |        |       |       |      - GPU: cupyx.scipy.fft (fallback to c |
|    69 |        |       |       |    """                                     |
|    70 |        |       |       |    if S.backend == "gpu":                  |
|    71 |        |       |       |        if _cpfft is not None:              |
|    72 |        |       |       |            return _cpfft                   |
|    73 |        |       |       |        return S.xp.fft                     |
|    74 |        |       |       |    return _spfft                           |
|    75 |        |       |       |                                            |
|    76 |        |       |       |# ========================================= |
|    77 |        |       |       |# Fortran-style random generator used in PA |
|    78 |        |       |       |# ========================================= |
|    79 |        |       |       |def frand(seed_list):                       |
|    80 |        |       |       |    """                                     |
|    81 |        |       |       |    Port of the Fortran LCG used in PAO:    |
|    82 |        |       |       |                                            |
|    83 |        |       |       |      IMM = 420029                          |
|    84 |        |       |       |      IT  = 2017                            |
|    85 |        |       |       |      ID  = 5011                            |
|    86 |        |       |       |                                            |
|    87 |        |       |       |      seed = (seed*IMM + IT) mod ID         |
|    88 |        |       |       |      r    = seed / ID                      |
|    89 |        |       |       |                                            |
|    90 |        |       |       |    `seed_list` is a 1-element list to mimi |
|    91 |        |       |       |    """                                     |
|    92 |        |       |       |    IMM = 420029                            |
|    93 |        |       |       |    IT = 2017                               |
|    94 |        |       |       |    ID = 5011                               |
|    95 |        |       |       |                                            |
|    96 |        |       |       |    seed_list[0] = (seed_list[0] * IMM + IT |
|    97 |        |       |       |    return np.float32(seed_list[0] / ID)    |
|    98 |        |       |       |                                            |
|    99 |        |       |       |                                            |
|   100 |        |       |       |# ----------------------------------------- |
|   101 |        |       |       |# Backend selection: xp = np (CPU) or cp (G |
|   102 |        |       |       |# ----------------------------------------- |
|   103 |        |       |       |def get_xp(backend: Literal["cpu", "gpu", " |
|   104 |        |       |       |    """                                     |
|   105 |        |       |       |    backend = "gpu"  â†’ force CuPy cuFFT ( |
|   106 |        |       |       |    backend = "cpu"  â†’ force SciPy FFT    |
|   107 |        |       |       |    backend = "auto" â†’ use CuPy if availa |
|   108 |        |       |       |    """                                     |
|   109 |        |       |       |    # Auto-select: try GPU first            |
|   110 |        |       |       |    if backend == "auto":                   |
|   111 |        |       |       |        if _cp is not None:                 |
|   112 |        |       |       |            return _cp                      |
|   113 |        |       |       |        return _np                          |
|   114 |        |       |       |                                            |
|   115 |        |       |       |    # Explicit GPU / CPU selection          |
|   116 |        |       |       |    if backend == "gpu":                    |
|   117 |        |       |       |        if _cp is None:                     |
|   118 |        |       |       |            raise RuntimeError("CuPy is not |
|   119 |        |       |       |        return _cp                          |
|   120 |        |       |       |                                            |
|   121 |        |       |       |    # backend == "cpu"                      |
|   122 |        |       |       |    return _np                              |
|   123 |        |       |       |                                            |
|   124 |        |       |       |                                            |
|   125 |        |       |       |# ----------------------------------------- |
|   126 |        |       |       |# Fortran-style random generator used in PA |
|   127 |        |       |       |# ----------------------------------------- |
|   128 |        |       |       |                                            |
|   129 |        |       |       |class Frand:                                |
|   130 |        |       |       |    """                                     |
|   131 |        |       |       |    Port of the tiny LCG from dns_all.cu:   |
|   132 |        |       |       |                                            |
|   133 |        |       |       |      IMM = 420029                          |
|   134 |        |       |       |      IT  = 2017                            |
|   135 |        |       |       |      ID  = 5011                            |
|   136 |        |       |       |                                            |
|   137 |        |       |       |      seed = (seed*IMM + IT) % ID           |
|   138 |        |       |       |      r    = seed / ID                      |
|   139 |        |       |       |    """                                     |
|   140 |        |       |       |    IMM = 420029                            |
|   141 |        |       |       |    IT = 2017                               |
|   142 |        |       |       |    ID = 5011                               |
|   143 |        |       |       |                                            |
|   144 |        |       |       |    def __init__(self, seed: int = 1):      |
|   145 |        |       |       |        self.seed = int(seed)               |
|   146 |        |       |       |                                            |
|   147 |        |       |       |    def __call__(self) -> float:            |
|   148 |        |       |       |        self.seed = (self.seed * self.IMM + |
|   149 |        |       |       |        return float(self.seed) / float(sel |
|   150 |        |       |       |                                            |
|   151 |        |       |       |                                            |
|   152 |        |       |       |# ========================================= |
|   153 |        |       |       |# Python equivalent of dnsCudaDumpUCFullCsv |
|   154 |        |       |       |# ========================================= |
|   155 |        |       |       |def dump_uc_full_csv(S: "DnsState", UC_full |
|   156 |        |       |       |    """                                     |
|   157 |        |       |       |    CSV dumper compatible with step2a_debug |
|   158 |        |       |       |                                            |
|   159 |        |       |       |        UC_full: (3, NZ_full, NK_full)  # [ |
|   160 |        |       |       |                                            |
|   161 |        |       |       |    We print NX_full rows, NZ_full columns: |
|   162 |        |       |       |      - For i < 2*ND2:                      |
|   163 |        |       |       |          kx       = i // 2                 |
|   164 |        |       |       |          imag_row = (i & 1) == 1           |
|   165 |        |       |       |          value    = Re or Im of UC_full[co |
|   166 |        |       |       |      - For i >= 2*ND2, we print 0.0 (as in |
|   167 |        |       |       |    """                                     |
|   168 |        |       |       |    N = S.Nbase                             |
|   169 |        |       |       |    NX_full = S.NX_full                     |
|   170 |        |       |       |    NZ_full = S.NZ_full                     |
|   171 |        |       |       |    NK_full = S.NK_full                     |
|   172 |        |       |       |    ND2 = N // 2                            |
|   173 |        |       |       |                                            |
|   174 |        |       |       |    # Bring data to NumPy on CPU for printi |
|   175 |        |       |       |    if S.backend == "gpu":                  |
|   176 |        |       |       |        UC_local = _np.asarray(UC_full.get( |
|   177 |        |       |       |    else:                                   |
|   178 |        |       |       |        UC_local = _np.asarray(UC_full)     |
|   179 |        |       |       |                                            |
|   180 |        |       |       |    for i in range(NX_full):                |
|   181 |        |       |       |        row_vals = []                       |
|   182 |        |       |       |                                            |
|   183 |        |       |       |        use_mode = (i < 2 * ND2)            |
|   184 |        |       |       |        if use_mode:                        |
|   185 |        |       |       |            kx = i // 2           # 0..ND2- |
|   186 |        |       |       |            imag_row = (i & 1) == 1         |
|   187 |        |       |       |        else:                               |
|   188 |        |       |       |            kx = None                       |
|   189 |        |       |       |            imag_row = False  # unused      |
|   190 |        |       |       |                                            |
|   191 |        |       |       |        for z in range(NZ_full):            |
|   192 |        |       |       |            if use_mode and kx < NK_full:   |
|   193 |        |       |       |                # SoA layout: [comp, z, kx] |
|   194 |        |       |       |                v = UC_local[comp, z, kx]   |
|   195 |        |       |       |                val = float(v.imag if imag_ |
|   196 |        |       |       |            else:                           |
|   197 |        |       |       |                val = 0.0                   |
|   198 |        |       |       |                                            |
|   199 |        |       |       |            row_vals.append(f"{val:10.5f}") |
|   200 |        |       |       |                                            |
|   201 |        |       |       |        print(",".join(row_vals))           |
|   202 |        |       |       |                                            |
|   203 |        |       |       |    print(f"[CSV] Wrote UC_full, {NX_full}x |
|   204 |        |       |       |                                            |
|   205 |        |       |       |                                            |
|   206 |        |       |       |# ----------------------------------------- |
|   207 |        |       |       |# DNS state  (Python equivalent of DnsDevic |
|   208 |        |       |       |# ----------------------------------------- |
|   209 |        |       |       |                                            |
|   210 |        |       |       |@dataclass                                  |
|   211 |        |       |       |class DnsState:                             |
|   212 |        |       |       |    xp: any                 # scipy or cupy |
|   213 |        |       |       |    backend: str            # "cpu" or "gpu |
|   214 |        |       |       |                                            |
|   215 |        |       |       |    Nbase: int              # Fortran NX=NZ |
|   216 |        |       |       |    NX: int                                 |
|   217 |        |       |       |    NZ: int                                 |
|   218 |        |       |       |    NK: int                                 |
|   219 |        |       |       |                                            |
|   220 |        |       |       |    NX_full: int                            |
|   221 |        |       |       |    NZ_full: int                            |
|   222 |        |       |       |    NK_full: int                            |
|   223 |        |       |       |                                            |
|   224 |        |       |       |    Re: float                               |
|   225 |        |       |       |    K0: float                               |
|   226 |        |       |       |    visc: float             # viscosity     |
|   227 |        |       |       |    cflnum: float           # CFL target    |
|   228 |        |       |       |    seed_init: int = 1                      |
|   229 |        |       |       |    fft_workers: int = 1                    |
|   230 |        |       |       |                                            |
|   231 |        |       |       |    # Cached FFT module (scipy.fft or cupyx |
|   232 |        |       |       |    fft: any = None                         |
|   233 |        |       |       |                                            |
|   234 |        |       |       |    # Reusable cuFFT plans (GPU only)       |
|   235 |        |       |       |    fft_plan_rfft2_ur_full: any = None      |
|   236 |        |       |       |    fft_plan_irfft2_uc01: any = None        |
|   237 |        |       |       |                                            |
|   238 |        |       |       |    # Precomputed grid constants for CFL co |
|   239 |        |       |       |    inv_dx: float = 0.0                     |
|   240 |        |       |       |                                            |
|   241 |        |       |       |    # CFL scratch to avoid per-step allocat |
|   242 |        |       |       |    cfl_tmp: any = None                     |
|   243 |        |       |       |    cfl_absw: any = None                    |
|   244 |        |       |       |                                            |
|   245 |        |       |       |    # Time integration                      |
|   246 |        |       |       |    t: float = 0.0                          |
|   247 |        |       |       |    dt: float = 0.0                         |
|   248 |        |       |       |    cn: float = 1.0                         |
|   249 |        |       |       |    cnm1: float = 0.0                       |
|   250 |        |       |       |    it: int = 0                             |
|   251 |        |       |       |                                            |
|   252 |        |       |       |    # Spectral wavenumber vectors           |
|   253 |        |       |       |    alfa: any = None        # shape (NX_hal |
|   254 |        |       |       |    gamma: any = None       # shape (NZ,)   |
|   255 |        |       |       |                                            |
|   256 |        |       |       |    # Compact grid (AoS)                    |
|   257 |        |       |       |    ur: any = None          # shape (NZ, NX |
|   258 |        |       |       |    uc: any = None          # shape (NZ, NK |
|   259 |        |       |       |                                            |
|   260 |        |       |       |    # Full 3/2 grid (SoA)                   |
|   261 |        |       |       |    ur_full: any = None     # shape (3, NZ_ |
|   262 |        |       |       |    uc_full: any = None     # shape (3, NZ_ |
|   263 |        |       |       |                                            |
|   264 |        |       |       |    # Vorticity and non-linear history      |
|   265 |        |       |       |    om2: any = None         # shape (NZ, NX |
|   266 |        |       |       |    fnm1: any = None        # shape (NZ, NX |
|   267 |        |       |       |                                            |
|   268 |        |       |       |    scratch1: any = None                    |
|   269 |        |       |       |    scratch2: any = None                    |
|   270 |        |       |       |                                            |
|   271 |        |       |       |    # Precomputed index grids for STEP3 (av |
|   272 |        |       |       |    step3_z_indices: any = None             |
|   273 |        |       |       |    step3_kx_indices: any = None            |
|   274 |        |       |       |    step3_z_spec: any = None                |
|   275 |        |       |       |                                            |
|   276 |        |       |       |    # STEP3 scratch buffers & constants (av |
|   277 |        |       |       |    step3_uc1_th: any = None                |
|   278 |        |       |       |    step3_uc2_th: any = None                |
|   279 |        |       |       |    step3_uc3_th: any = None                |
|   280 |        |       |       |                                            |
|   281 |        |       |       |    step3_K2: any = None          # float32 |
|   282 |        |       |       |    step3_GA: any = None          # float32 |
|   283 |        |       |       |    step3_G2mA2: any = None       # float32 |
|   284 |        |       |       |    step3_invK2_sub: any = None   # float32 |
|   285 |        |       |       |                                            |
|   286 |        |       |       |    step3_ARG: any = None         # float32 |
|   287 |        |       |       |    step3_DEN: any = None         # float32 |
|   288 |        |       |       |    step3_NUM: any = None         # complex |
|   289 |        |       |       |                                            |
|   290 |        |       |       |    step3_mask_ix0: any = None    # bool (N |
|   291 |        |       |       |    step3_divxz: any = None       # float32 |
|   292 |        |       |       |                                            |
|   293 |        |       |       |    def sync(self):                         |
|   294 |        |       |       |        """For a CuPy backend, force synchr |
|   295 |        |       |       |        if self.backend == "gpu":           |
|   296 |        |       |       |            self.xp.cuda.Stream.null.synchr |
|   297 |        |       |       |                                            |
|   298 |        |       |       |                                            |
|   299 |        |       |       |# ----------------------------------------- |
|   300 |        |       |       |# Helper to create a DnsState (dnsCudaInit  |
|   301 |        |       |       |# ----------------------------------------- |
|   302 |        |       |       |                                            |
|   303 |        |       |       |def create_dns_state(                       |
|   304 |        |       |       |    N: int = 8,                             |
|   305 |        |       |       |    Re: float = 1e5,                        |
|   306 |        |       |       |    K0: float = 100.0,                      |
|   307 |        |       |       |    CFL: float = 0.75,                      |
|   308 |        |       |       |    backend: Literal["cpu", "gpu", "auto"]  |
|   309 |        |       |       |    seed: int = 1,                          |
|   310 |        |       |       |) -> DnsState:                              |
|   311 |        |       |       |    xp = get_xp(backend)                    |
|   312 |        |       |       |                                            |
|   313 |        |       |       |    if backend == "auto":                   |
|   314 |        |       |       |        effective_backend = "gpu" if (_cp i |
|   315 |        |       |       |    else:                                   |
|   316 |        |       |       |        effective_backend = backend         |
|   317 |        |       |       |                                            |
|   318 |        |       |       |    print(f" backend:  {backend}")          |
|   319 |        |       |       |    Nbase = N                               |
|   320 |        |       |       |    NX = N                                  |
|   321 |        |       |       |    NZ = N                                  |
|   322 |        |       |       |                                            |
|   323 |        |       |       |    # Your CUDA code uses 3*N/2 (full 3/2 g |
|   324 |        |       |       |    NX_full = 3 * NX // 2                   |
|   325 |        |       |       |    NZ_full = 3 * NZ // 2                   |
|   326 |        |       |       |    NK_full = NX_full // 2 + 1              |
|   327 |        |       |       |                                            |
|   328 |        |       |       |    # Compact spectral NK:                  |
|   329 |        |       |       |    # For the original PAO/Calcom you used  |
|   330 |        |       |       |    NK = 3 * NX // 4 + 1                    |
|   331 |        |       |       |                                            |
|   332 |        |       |       |    NX_half = NX // 2                       |
|   333 |        |       |       |                                            |
|   334 |        |       |       |    # Viscosity: in your original Fortran/C |
|   335 |        |       |       |    # from PAO/Calcom; here we keep a stand |
|   336 |        |       |       |    visc = 1.0 / float(Re)                  |
|   337 |        |       |       |                                            |
|   338 |        |       |       |    state = DnsState(                       |
|   339 |        |       |       |        xp=xp,                              |
|   340 |        |       |       |        backend=effective_backend,          |
|   341 |        |       |       |        Nbase=Nbase,                        |
|   342 |        |       |       |        NX=NX,                              |
|   343 |        |       |       |        NZ=NZ,                              |
|   344 |        |       |       |        NK=NK,                              |
|   345 |        |       |       |        NX_full=NX_full,                    |
|   346 |        |       |       |        NZ_full=NZ_full,                    |
|   347 |        |       |       |        NK_full=NK_full,                    |
|   348 |        |       |       |        Re=Re,                              |
|   349 |        |       |       |        K0=K0,                              |
|   350 |        |       |       |        visc=visc,                          |
|   351 |        |       |       |        cflnum=CFL,                         |
|   352 |        |       |       |        seed_init=int(seed),                |
|   353 |        |       |       |        fft_workers=5,                      |
|   354 |        |       |       |    )                                       |
|   355 |        |       |       |    print(f" workers (CPU): {state.fft_work |
|   356 |        |       |       |                                            |
|   357 |        |       |       |    # Cache FFT module for the chosen backe |
|   358 |        |       |       |    state.fft = _fft_mod_for_state(state)   |
|   359 |        |       |       |                                            |
|   360 |        |       |       |    # Precompute inverse grid spacing (dx== |
|   361 |        |       |       |    state.inv_dx = float(state.Nbase) / (2. |
|   362 |        |       |       |                                            |
|   363 |        |       |       |    # Allocate arrays                       |
|   364 |        |       |       |    state.ur = xp.zeros((NZ, NX, 3), dtype= |
|   365 |        |       |       |    state.uc = xp.zeros((NZ, NK, 3), dtype= |
|   366 |        |       |       |                                            |
|   367 |        |       |       |    state.ur_full = xp.zeros((3, NZ_full, N |
|   368 |        |       |       |    state.uc_full = xp.zeros((3, NZ_full, N |
|   369 |        |       |       |                                            |
|   370 |        |       |       |    # CFL scratch buffers (full 3/2 grid) t |
|   371 |        |       |       |    state.cfl_tmp = xp.empty((NZ_full, NX_f |
|   372 |        |       |       |    state.cfl_absw = xp.empty((NZ_full, NX_ |
|   373 |        |       |       |                                            |
|   374 |        |       |       |    state.om2 = xp.zeros((NZ, NX_half), dty |
|   375 |        |       |       |    state.fnm1 = xp.zeros((NZ, NX_half), dt |
|   376 |        |       |       |                                            |
|   377 |        |       |       |    state.alfa = xp.zeros((NX_half,), dtype |
|   378 |        |       |       |    state.gamma = xp.zeros((NZ,), dtype=xp. |
|   379 |        |       |       |                                            |
|   380 |        |       |       |    # Reusable cuFFT plans (GPU only)       |
|   381 |        |       |       |    if state.backend == "gpu":              |
|   382 |        |       |       |        plan_mod = None                     |
|   383 |        |       |       |        if _cpfft is not None and hasattr(_ |
|   384 |        |       |       |            plan_mod = _cpfft               |
|   385 |        |       |       |                                            |
|   386 |        |       |       |        if plan_mod is not None:            |
|   387 |        |       |       |            # Forward: rfft2 on real UR_ful |
|   388 |        |       |       |            state.fft_plan_rfft2_ur_full =  |
|   389 |        |       |       |                state.ur_full, axes=(1, 2), |
|   390 |        |       |       |            )                               |
|   391 |        |       |       |            # Inverse: irfft2 on UC_full[0: |
|   392 |        |       |       |            state.fft_plan_irfft2_uc01 = pl |
|   393 |        |       |       |                state.uc_full[0:2],         |
|   394 |        |       |       |                shape=(state.NZ_full, state |
|   395 |        |       |       |                axes=(1, 2),                |
|   396 |        |       |       |                value_type="C2R",           |
|   397 |        |       |       |            )                               |
|   398 |        |       |       |                                            |
|   399 |        |       |       |        if plan_mod is None:                |
|   400 |        |       |       |            print("FFT plan_mod: None")     |
|   401 |        |       |       |        else:                               |
|   402 |        |       |       |            print(f"FFT plan_mod: {plan_mod |
|   403 |        |       |       |                                            |
|   404 |        |       |       |    # PAO-style initialization (dnsCudaPaoH |
|   405 |        |       |       |    dns_pao_host_init(state)                |
|   406 |        |       |       |                                            |
|   407 |        |       |       |    # DT and CN will be initialized in run_ |
|   408 |        |       |       |    state.dt = 0.0                          |
|   409 |        |       |       |    state.cn = 1.0                          |
|   410 |        |       |       |    state.cnm1 = 0.0                        |
|   411 |        |       |       |                                            |
|   412 |        |       |       |    state.scratch1 = xp.zeros((NZ, NX_half) |
|   413 |        |       |       |    state.scratch2 = xp.zeros((NZ, NX_half) |
|   414 |        |       |       |                                            |
|   415 |        |       |       |    # Precompute index grids used in STEP3  |
|   416 |        |       |       |    NZ = state.NZ                           |
|   417 |        |       |       |    NX_half = state.NX // 2                 |
|   418 |        |       |       |    state.step3_z_indices = xp.arange(NZ, d |
|   419 |        |       |       |    state.step3_kx_indices = xp.arange(NX_h |
|   420 |        |       |       |    NZ_half = NZ // 2                       |
|   421 |        |       |       |    zi = state.step3_z_indices              |
|   422 |        |       |       |    state.step3_z_spec = xp.where(          |
|   423 |        |       |       |        zi <= (NZ_half - 1),                |
|   424 |        |       |       |        zi,                                 |
|   425 |        |       |       |        zi + NZ_half,                       |
|   426 |        |       |       |    )                                       |
|   427 |        |       |       |                                            |
|   428 |        |       |       |    # STEP3: preallocate gather buffers for |
|   429 |        |       |       |    state.step3_uc1_th = xp.empty((NZ, NX_h |
|   430 |        |       |       |    state.step3_uc2_th = xp.empty((NZ, NX_h |
|   431 |        |       |       |    state.step3_uc3_th = xp.empty((NZ, NX_h |
|   432 |        |       |       |                                            |
|   433 |        |       |       |    # STEP3: precompute constant spectral g |
|   434 |        |       |       |    ax = state.alfa[None, :]          # (1, |
|   435 |        |       |       |    gz = state.gamma[:, None]         # (NZ |
|   436 |        |       |       |    ax2 = ax * ax                           |
|   437 |        |       |       |    gz2 = gz * gz                           |
|   438 |        |       |       |                                            |
|   439 |        |       |       |    state.step3_K2 = (ax2 + gz2).astype(xp. |
|   440 |        |       |       |    state.step3_GA = (gz * ax).astype(xp.fl |
|   441 |        |       |       |    state.step3_G2mA2 = (gz2 - ax2).astype( |
|   442 |        |       |       |                                            |
|   443 |        |       |       |    if NX_half > 1:                         |
|   444 |        |       |       |        state.step3_invK2_sub = (xp.float32 |
|   445 |        |       |       |    else:                                   |
|   446 |        |       |       |        state.step3_invK2_sub = xp.empty((N |
|   447 |        |       |       |                                            |
|   448 |        |       |       |    # STEP3: per-step float/complex scratch |
|   449 |        |       |       |    state.step3_ARG = xp.empty((NZ, NX_half |
|   450 |        |       |       |    state.step3_DEN = xp.empty((NZ, NX_half |
|   451 |        |       |       |    state.step3_NUM = xp.empty((NZ, NX_half |
|   452 |        |       |       |                                            |
|   453 |        |       |       |    # ix=0 branch mask (Z>=2 and GAMMA!=0), |
|   454 |        |       |       |    state.step3_mask_ix0 = (state.step3_z_i |
|   455 |        |       |       |                                            |
|   456 |        |       |       |    # DIVXZ = 1/(3NX/2 * 3NZ/2), constant f |
|   457 |        |       |       |    NX32 = xp.float32(1.5) * xp.float32(sta |
|   458 |        |       |       |    NZ32 = xp.float32(1.5) * xp.float32(sta |
|   459 |        |       |       |    state.step3_divxz = xp.float32(1.0) / ( |
|   460 |        |       |       |                                            |
|   461 |        |       |       |    return state                            |
|   462 |        |       |       |                                            |
|   463 |        |       |       |# ========================================= |
|   464 |        |       |       |# Python/Numpy/Scipy port of dnsCudaPaoHost |
|   465 |        |       |       |# ========================================= |
|   466 |        |       |       |def dns_pao_host_init(S: DnsState):         |
|   467 |        |       |       |    xp = S.xp                               |
|   468 |        |       |       |    N = S.NX                                |
|   469 |        |       |       |    NE = S.NZ                               |
|   470 |        |       |       |    ND2 = N // 2                            |
|   471 |        |       |       |    NED2 = NE // 2                          |
|   472 |        |       |       |    PI = np.float32(3.14159265358979)       |
|   473 |        |       |       |                                            |
|   474 |        |       |       |    DXZ = np.float32(2.0) * PI / np.float32 |
|   475 |        |       |       |    K0 = np.float32(S.K0)                   |
|   476 |        |       |       |    NORM = PI * K0 * K0                     |
|   477 |        |       |       |                                            |
|   478 |        |       |       |    print("--- INITIALIZING SciPy/CuPy ---" |
|   479 |        |       |       |    print(f" N={N}, K0={int(K0)}, Re={S.Re} |
|   480 |        |       |       |                                            |
|   481 |        |       |       |    # ------------------------------------- |
|   482 |        |       |       |    # Build ALFA(N/2) and GAMMA(N)  (Fortra |
|   483 |        |       |       |    # ------------------------------------- |
|   484 |        |       |       |    alfa = np.zeros(ND2, dtype=np.float32)  |
|   485 |        |       |       |    gamma = np.zeros(NE, dtype=np.float32)  |
|   486 |        |       |       |                                            |
|   487 |        |       |       |    E1 = np.float32(1.0)                    |
|   488 |        |       |       |    E3 = np.float32(1.0) / E1               |
|   489 |        |       |       |                                            |
|   490 |        |       |       |    DALFA = np.float32(1.0) / E1            |
|   491 |        |       |       |    DGAMMA = np.float32(1.0) / E3           |
|   492 |        |       |       |                                            |
|   493 |        |       |       |    for x in range(NED2):                   |
|   494 |        |       |       |        alfa[x] = np.float32(x) * DALFA     |
|   495 |        |       |       |                                            |
|   496 |        |       |       |    gamma[0] = np.float32(0.0)              |
|   497 |        |       |       |    for z in range(1, NED2 + 1):            |
|   498 |        |       |       |        gamma[z] = np.float32(z) * DGAMMA   |
|   499 |        |       |       |        gamma[NE - z] = -gamma[z]           |
|   500 |        |       |       |                                            |
|   501 |        |       |       |    # ------------------------------------- |
|   502 |        |       |       |    # Host spectral UR: complex field UR(kx |
|   503 |        |       |       |    # comp=0 â†’ u1, comp=1 â†’ u3 (Fortran |
|   504 |        |       |       |    #                                       |
|   505 |        |       |       |    #   UR[x,z,c]  where  x âˆˆ [0..ND2-1], |
|   506 |        |       |       |    # ------------------------------------- |
|   507 |        |       |       |    UR = np.zeros((ND2, NE, 2), dtype=np.co |
|   508 |        |       |       |                                            |
|   509 |        |       |       |    # ------------------------------------- |
|   510 |        |       |       |    # Fortran random vector RANVEC(97)      |
|   511 |        |       |       |    # ------------------------------------- |
|   512 |        |       |       |    seed = [int(S.seed_init)]  # mimics ISE |
|   513 |        |       |       |    RANVEC = np.zeros(97, dtype=np.float32) |
|   514 |        |       |       |                                            |
|   515 |        |       |       |    # "warm-up" 97 calls                    |
|   516 |        |       |       |    for _ in range(97):                     |
|   517 |        |       |       |        frand(seed)                         |
|   518 |        |       |       |                                            |
|   519 |        |       |       |    # fill RANVEC                           |
|   520 |        |       |       |    for i in range(97):                     |
|   521 |        |       |       |        RANVEC[i] = frand(seed)             |
|   522 |        |       |       |                                            |
|   523 |        |       |       |    def random_from_vec(r: np.float32) -> n |
|   524 |        |       |       |        idx = int(float(r) * 97.0)          |
|   525 |        |       |       |        if idx < 0:                         |
|   526 |        |       |       |            idx = 0                         |
|   527 |        |       |       |        if idx > 96:                        |
|   528 |        |       |       |            idx = 96                        |
|   529 |        |       |       |        v = RANVEC[idx]                     |
|   530 |        |       |       |        RANVEC[idx] = r                     |
|   531 |        |       |       |        return v                            |
|   532 |        |       |       |                                            |
|   533 |        |       |       |    # ------------------------------------- |
|   534 |        |       |       |    # Generate isotropic random spectrum (F |
|   535 |        |       |       |    # ------------------------------------- |
|   536 |        |       |       |    print("Generate isotropic random spectr |
|   537 |        |       |       |    for z in range(NE):                     |
|   538 |        |       |       |        if z % 1000 == 0:                   |
|   539 |        |       |       |            print(f"z={z}/{NE}")            |
|   540 |        |       |       |                                            |
|   541 |        |       |       |        gz = gamma[z]                       |
|   542 |        |       |       |        for x in range(NED2):               |
|   543 |        |       |       |            r = frand(seed)                 |
|   544 |        |       |       |            th = np.float32(2.0) * PI * ran |
|   545 |        |       |       |                                            |
|   546 |        |       |       |            ARG = np.complex64(np.cos(th) + |
|   547 |        |       |       |                                            |
|   548 |        |       |       |            ax = alfa[x]                    |
|   549 |        |    3% |       |            K2 = np.float32(ax * ax + gz *  |
|   550 |        |       |       |            K = np.float32(np.sqrt(K2)) if  |
|   551 |        |       |       |                                            |
|   552 |        |       |       |            if ax == 0.0:                   |
|   553 |        |       |       |                # ALFA(X) == 0: purely u1 m |
|   554 |        |       |       |                UR[x, z, 1] = np.complex64( |
|   555 |        |       |       |                                            |
|   556 |        |       |       |                ABSU2 = np.float32(np.exp(- |
|   557 |        |       |       |                amp = np.float32(np.sqrt(AB |
|   558 |        |       |       |                UR[x, z, 0] = np.complex64( |
|   559 |        |       |       |            else:                           |
|   560 |        |       |       |                denom = np.float32(1.0) + ( |
|   561 |        |    1% |       |                ABSW2 = np.float32(np.exp(- |
|   562 |        |    1% |       |                ampw = np.float32(np.sqrt(A |
|   563 |        |       |       |                                            |
|   564 |        |       |       |                w = np.complex64(ampw) * AR |
|   565 |        |       |       |                u = np.complex64(- (gz / ax |
|   566 |        |       |       |                                            |
|   567 |        |       |       |                UR[x, z, 1] = w             |
|   568 |        |       |       |                UR[x, z, 0] = u             |
|   569 |        |       |       |                                            |
|   570 |        |       |       |    # Special zero modes (UR(1,1,1)=0, UR(1 |
|   571 |        |       |       |    UR[0, 0, 0] = np.complex64(0.0 + 0.0j)  |
|   572 |        |       |       |    UR[0, 0, 1] = np.complex64(0.0 + 0.0j)  |
|   573 |        |       |       |                                            |
|   574 |        |       |       |    # ------------------------------------- |
|   575 |        |       |       |    # Hermitian symmetry in Z (Fortran DO 6 |
|   576 |        |       |       |    # ------------------------------------- |
|   577 |        |       |       |    for z in range(1, NED2):                |
|   578 |        |       |       |        UR[0, NE - z, 0] = np.conj(UR[0, z, |
|   579 |        |       |       |        UR[0, NE - z, 1] = np.conj(UR[0, z, |
|   580 |        |       |       |                                            |
|   581 |        |       |       |    # Zero at Z=NED2+1 (index NED2 in 0-bas |
|   582 |        |       |       |    UR[:, NED2, 0] = 0.0 + 0.0j             |
|   583 |        |       |       |    UR[:, NED2, 1] = 0.0 + 0.0j             |
|   584 |        |       |       |                                            |
|   585 |        |       |       |    # ------------------------------------- |
|   586 |        |       |       |    # Compute averages A(1..7), E110, Q2, W |
|   587 |        |       |       |    # ------------------------------------- |
|   588 |        |       |       |    A1 = A2 = A3 = A4 = A5 = A6 = A7 = 0.0  |
|   589 |        |       |       |    E110 = 0.0                              |
|   590 |        |       |       |                                            |
|   591 |        |       |       |    print("Compute averages A(1..7), E110,  |
|   592 |        |       |       |    for x in range(ND2):                    |
|   593 |        |       |       |        x1 = (x == 0)                       |
|   594 |        |       |       |        ax2 = float(alfa[x]) * float(alfa[x |
|   595 |        |       |       |                                            |
|   596 |        |       |       |        for z in range(NE):                 |
|   597 |        |       |       |            U1 = UR[x, z, 0]                |
|   598 |        |       |       |            U3 = UR[x, z, 1]                |
|   599 |        |       |       |                                            |
|   600 |        |    1% |       |            u1u1 = float(np.abs(U1) ** 2)   |
|   601 |        |       |       |            u3u3 = float(np.abs(U3) ** 2)   |
|   602 |        |       |       |                                            |
|   603 |        |       |       |            gz2 = float(gamma[z]) * float(g |
|   604 |        |       |       |            K2 = ax2 + gz2                  |
|   605 |        |       |       |            m = 1.0 if x1 else 2.0          |
|   606 |        |       |       |                                            |
|   607 |        |       |       |            A1 += m * u1u1                  |
|   608 |        |       |       |            A2 += m * u3u3                  |
|   609 |        |       |       |            A3 += m * u1u1 * ax2            |
|   610 |        |       |       |            A4 += m * u1u1 * gz2            |
|   611 |        |       |       |            A5 += m * u3u3 * ax2            |
|   612 |        |       |       |            A6 += m * u3u3 * gz2            |
|   613 |        |       |       |            A7 += m * (u1u1 + u3u3) * K2 *  |
|   614 |        |       |       |                                            |
|   615 |        |       |       |            if x1:                          |
|   616 |        |       |       |                E110 += u1u1                |
|   617 |        |       |       |                                            |
|   618 |        |       |       |    Q2 = A1 + A2                            |
|   619 |        |       |       |    W2 = A3 + A4 + A5 + A6                  |
|   620 |        |       |       |    visc = math.sqrt(Q2 * Q2 / (float(S.Re) |
|   621 |        |       |       |                                            |
|   622 |        |       |       |    S.visc = np.float32(visc)               |
|   623 |        |       |       |                                            |
|   624 |        |       |       |    # ------------------------------------- |
|   625 |        |       |       |    # Extra diagnostics (Fortran WRITE bloc |
|   626 |        |       |       |    # ------------------------------------- |
|   627 |        |       |       |    EP = visc * W2                          |
|   628 |        |       |       |    De = 2.0 * visc * visc * A7             |
|   629 |        |       |       |    KOL = (visc * visc * visc / EP) ** 0.25 |
|   630 |        |       |       |    NLAM = 0.0                              |
|   631 |        |       |       |    if E110 != 0.0:                         |
|   632 |        |       |       |        NLAM = 2.0 * A1 / E110              |
|   633 |        |       |       |                                            |
|   634 |        |       |       |    a11 = 2.0 * A1 / Q2 - 1.0               |
|   635 |        |       |       |    e11 = 2.0 * (A3 + A4) / W2 - 1.0        |
|   636 |        |       |       |    tscale = 0.5 * Q2 / EP                  |
|   637 |        |       |       |    dxKol = float(DXZ) / KOL                |
|   638 |        |       |       |    Lux = 2.0 * math.pi / math.sqrt(2.0 * A |
|   639 |        |       |       |    Luz = 2.0 * math.pi / math.sqrt(2.0 * A |
|   640 |        |       |       |    Lwx = 2.0 * math.pi / math.sqrt(2.0 * A |
|   641 |        |       |       |    Lwz = 2.0 * math.pi / math.sqrt(2.0 * A |
|   642 |        |       |       |    Ceps2 = 0.5 * Q2 * De / (EP * EP)       |
|   643 |        |       |       |                                            |
|   644 |        |       |       |    # Print diagnostics exactly like the CU |
|   645 |        |       |       |    print(f" N           ={N:12.0f}")       |
|   646 |        |       |       |    print(f" Reynolds n. ={float(S.Re):12.1 |
|   647 |        |       |       |    print(f" K0          ={K0:12.0f}")      |
|   648 |        |       |       |    print(f" Energy      ={Q2:12.4f}")      |
|   649 |        |       |       |    print(f" WiWi        ={W2:12.4f}")      |
|   650 |        |       |       |    print(f" Epsilon     ={EP:12.4f}")      |
|   651 |        |       |       |    print(f" a11         ={a11:12.4f}")     |
|   652 |        |       |       |    print(f" e11         ={e11:12.4f}")     |
|   653 |        |       |       |    print(f" Time scale  ={tscale:12.4g}")  |
|   654 |        |       |       |    print(f" Kolmogorov  ={KOL:12.4f}")     |
|   655 |        |       |       |    print(f" Viscosity   ={visc:12.4f}")    |
|   656 |        |       |       |    print(f" dx/Kol.     ={dxKol:12.4f}")   |
|   657 |        |       |       |    print(f" 2Pi/Nlamda  ={NLAM:12.4f}")    |
|   658 |        |       |       |    print(f" 2Pi/Lux     ={Lux:12.4f}")     |
|   659 |        |       |       |    print(f" 2Pi/Luz     ={Luz:12.4f}")     |
|   660 |        |       |       |    print(f" 2Pi/Lwx     ={Lwx:12.4f}")     |
|   661 |        |       |       |    print(f" 2Pi/Lwz     ={Lwz:12.4f}")     |
|   662 |        |       |       |    print(f" Deps.       ={De:12.4f}")      |
|   663 |        |       |       |    print(f" Ceps2       ={Ceps2:12.4f}")   |
|   664 |        |       |       |    print(f" E1          ={float(E1):12.4f} |
|   665 |        |       |       |    print(f" E3          ={float(E3):12.4f} |
|   666 |        |       |       |    print(f" PAO seed    ={seed[0]:12d}")   |
|   667 |        |       |       |                                            |
|   668 |        |       |       |    # ------------------------------------- |
|   669 |        |       |       |    # Reshuffle (Fortran DO 1000 block)     |
|   670 |        |       |       |    # ------------------------------------- |
|   671 |        |       |       |    for comp in range(2):                   |
|   672 |        |       |       |        for z in range(NED2 - 1, -1, -1):   |
|   673 |        |       |       |            for x in range(ND2):            |
|   674 |        |       |       |                # UR(X,N-NED2+Z,I) = UR(X,Z |
|   675 |        |       |       |                UR[x, N - NED2 + z, comp] = |
|   676 |        |       |       |                                            |
|   677 |        |       |       |                # IF(Z.LE.(N-NE)) UR(X,Z+NE |
|   678 |        |       |       |                if z <= (N - NE - 1):       |
|   679 |        |       |       |                    UR[x, z + NED2, comp] = |
|   680 |        |       |       |                                            |
|   681 |        |       |       |    # ------------------------------------- |
|   682 |        |       |       |    # Scatter spectral UR â†’ compact UC(kx |
|   683 |        |       |       |    #   UC: (NK, NE, 3) on host, but DnsSta |
|   684 |        |       |       |    # ------------------------------------- |
|   685 |        |       |       |    NK = S.NK                               |
|   686 |        |       |       |    UC_host = np.zeros((NK, NE, 3), dtype=n |
|   687 |        |       |       |                                            |
|   688 |        |       |       |    for z in range(NE):                     |
|   689 |        |       |       |        for x in range(ND2):                |
|   690 |        |       |       |            for c in range(2):              |
|   691 |        |       |       |                UC_host[x, z, c] = UR[x, z, |
|   692 |        |       |       |                                            |
|   693 |        |       |       |    # ALSO build full 3/2-grid UC_full (For |
|   694 |        |       |       |    NK_full = S.NK_full                     |
|   695 |        |       |       |    NZ_full = S.NZ_full                     |
|   696 |        |       |       |                                            |
|   697 |        |       |       |    UC_full_host = np.zeros((NK_full, NZ_fu |
|   698 |        |       |       |    for z in range(NE):                     |
|   699 |        |       |       |        for x in range(ND2):                |
|   700 |        |       |       |            for c in range(2):              |
|   701 |        |       |       |                UC_full_host[x, z, c] = UR[ |
|   702 |        |       |       |                                            |
|   703 |        |       |       |    print(f" PAO initialization OK. VISC={f |
|   704 |        |       |       |                                            |
|   705 |        |       |       |    # ------------------------------------- |
|   706 |        |       |       |    # Move alfa/gamma/UC/UC_full into DnsSt |
|   707 |        |       |       |    # ------------------------------------- |
|   708 |        |       |       |    S.alfa = xp.asarray(alfa, dtype=xp.floa |
|   709 |        |       |       |    S.gamma = xp.asarray(gamma, dtype=xp.fl |
|   710 |        |       |       |                                            |
|   711 |        |       |       |    # compact UC: host (NK, NE, 3) â†’ xp ( |
|   712 |        |       |       |    UC_xp = xp.asarray(UC_host)             |
|   713 |        |       |       |    S.uc[...] = xp.transpose(UC_xp, (1, 0,  |
|   714 |        |       |       |                                            |
|   715 |        |       |       |    # full UC_full: host (NK_full, NZ_full, |
|   716 |        |       |       |    UC_full_xp = xp.asarray(UC_full_host)   |
|   717 |        |       |       |    S.uc_full[...] = xp.transpose(UC_full_x |
|   718 |        |       |       |                                            |
|   719 |        |       |       |    # ------------------------------------- |
|   720 |        |       |       |    # Build initial UR_full & om2 from UC_f |
|   721 |        |       |       |    # ------------------------------------- |
|   722 |        |       |       |    # Inverse transform UC_full â†’ UR_full |
|   723 |        |       |       |    vfft_full_inverse_uc_full_to_ur_full(S) |
|   724 |        |       |       |                                            |
|   725 |        |       |       |    # Spectral vorticity from UC_full, like |
|   726 |        |       |       |    dns_calcom_from_uc_full(S)              |
|   727 |        |       |       |                                            |
|   728 |        |       |       |    # No history yet                        |
|   729 |        |       |       |    S.fnm1[...] = xp.zeros_like(S.om2)      |
|   730 |        |       |       |                                            |
|   731 |        |       |       |                                            |
|   732 |        |       |       |# ----------------------------------------- |
|   733 |        |       |       |# FFT helpers (vfft_full_* equivalents)     |
|   734 |        |       |       |# ----------------------------------------- |
|   735 |        |       |       |                                            |
|   736 |        |       |       |def vfft_full_inverse_uc_full_to_ur_full(S: |
|   737 |        |       |       |    xp = S.xp                               |
|   738 |        |       |       |    UC = S.uc_full                          |
|   739 |        |       |       |    fft = S.fft                             |
|   740 |        |       |       |    if fft is None:                         |
|   741 |        |       |       |        raise RuntimeError("scipy.fft is no |
|   742 |        |       |       |                                            |
|   743 |        |       |       |    UC01 = UC[0:2, :, :]                    |
|   744 |        |       |       |                                            |
|   745 |        |       |       |    if S.backend == "cpu":                  |
|   746 |        |       |       |        ur01 = fft.irfft2(UC01, s=(S.NZ_ful |
|   747 |        |       |       |    else:                                   |
|   748 |        |       |       |        plan = S.fft_plan_irfft2_uc01       |
|   749 |        |       |       |        if plan is not None:                |
|   750 |        |       |       |            with plan:                      |
|   751 |        |       |       |                ur01 = fft.irfft2(UC01, s=( |
|   752 |        |       |       |        else:                               |
|   753 |        |       |       |            ur01 = fft.irfft2(UC01, s=(S.NZ |
|   754 |        |       |       |                                            |
|   755 |        |       |       |    S.ur_full[0:2, :, :] = xp.asarray(ur01, |
|   756 |        |       |       |    S.ur_full[2, :, :] = xp.float32(0.0)    |
|   757 |        |       |       |                                            |
|   758 |        |       |       |                                            |
|   759 |        |       |       |def vfft_full_forward_ur_full_to_uc_full(S: |
|   760 |        |       |       |    """                                     |
|   761 |        |       |       |    UR_full (3, NZ_full, NX_full) â†’ UC_fu |
|   762 |        |       |       |                                            |
|   763 |        |       |       |    Correct forward:                        |
|   764 |        |       |       |      1) real FFT along x      (real â†’ co |
|   765 |        |       |       |      2) FFT along z           (complex â†’ |
|   766 |        |       |       |                                            |
|   767 |        |       |       |    ONLY CHANGE: use rfft2 on (z,x) axes.   |
|   768 |        |       |       |    """                                     |
|   769 |        |       |       |    # S.ur_full is already float32          |
|   770 |        |       |       |    UR = S.ur_full                          |
|   771 |        |       |       |    fft = S.fft                             |
|   772 |        |       |       |    if fft is None:                         |
|   773 |        |       |       |        raise RuntimeError("scipy.fft is no |
|   774 |        |       |       |                                            |
|   775 |        |       |       |    if S.backend == "cpu":                  |
|   776 |        |       |       |        # overwrite_x is safe here (UR_full |
|   777 |        |       |       |        UC = fft.rfft2(UR, s=(S.NZ_full, S. |
|   778 |        |       |       |    else:                                   |
|   779 |        |       |       |        plan = S.fft_plan_rfft2_ur_full     |
|   780 |        |       |       |        if plan is not None:                |
|   781 |        |       |       |            with plan:                      |
|   782 |        |       |       |                UC = fft.rfft2(UR, s=(S.NZ_ |
|   783 |        |       |       |        else:                               |
|   784 |        |       |       |            UC = fft.rfft2(UR, s=(S.NZ_full |
|   785 |        |       |       |                                            |
|   786 |        |       |       |    # Assign back; uc_full is complex64, as |
|   787 |        |       |       |    S.uc_full[...] = UC                     |
|   788 |        |       |       |                                            |
|   789 |        |       |       |                                            |
|   790 |        |       |       |# ----------------------------------------- |
|   791 |        |       |       |# CALCOM â€” spectral vorticity from UC_ful |
|   792 |        |       |       |# ----------------------------------------- |
|   793 |        |       |       |                                            |
|   794 |        |       |       |def dns_calcom_from_uc_full(S: DnsState) -> |
|   795 |        |       |       |    """                                     |
|   796 |        |       |       |    Python/xp port of dnsCudaCalcom:        |
|   797 |        |       |       |                                            |
|   798 |        |       |       |      OM2(ix,iz) = i * [ GAMMA(iz)*UC1(ix,i |
|   799 |        |       |       |                                            |
|   800 |        |       |       |    Uses:                                   |
|   801 |        |       |       |      S.uc_full : (3, NZ_full, NK_full)  [c |
|   802 |        |       |       |      S.alfa    : (NX_half,)                |
|   803 |        |       |       |      S.gamma   : (NZ,)                     |
|   804 |        |       |       |    Writes:                                 |
|   805 |        |       |       |      S.om2     : (NZ, NX_half)             |
|   806 |        |       |       |    """                                     |
|   807 |        |       |       |    xp = S.xp                               |
|   808 |        |       |       |                                            |
|   809 |        |       |       |    Nbase = int(S.Nbase)                    |
|   810 |        |       |       |    NX_full = int(S.NX_full)                |
|   811 |        |       |       |    NZ_full = int(S.NZ_full)                |
|   812 |        |       |       |    NK_full = int(S.NK_full)                |
|   813 |        |       |       |                                            |
|   814 |        |       |       |    NX_half = Nbase // 2                    |
|   815 |        |       |       |    NZ = Nbase                              |
|   816 |        |       |       |                                            |
|   817 |        |       |       |    alfa_1d = S.alfa.astype(xp.float32)     |
|   818 |        |       |       |    gamma_1d = S.gamma.astype(xp.float32)   |
|   819 |        |       |       |                                            |
|   820 |        |       |       |    # UC_full layout: [comp, z, kx]         |
|   821 |        |       |       |    uc1_full = S.uc_full[0]                 |
|   822 |        |       |       |    uc2_full = S.uc_full[1]                 |
|   823 |        |       |       |                                            |
|   824 |        |       |       |    # We only use the first NZ rows and NX_ |
|   825 |        |       |       |    uc1 = uc1_full[:NZ, :NX_half]           |
|   826 |        |       |       |    uc2 = uc2_full[:NZ, :NX_half]           |
|   827 |        |       |       |                                            |
|   828 |        |       |       |    ax = alfa_1d[None, :]                   |
|   829 |        |       |       |    gz = gamma_1d[:, None]                  |
|   830 |        |       |       |                                            |
|   831 |        |       |       |    # diff = GAMMA*UC1 - ALFA*UC2           |
|   832 |        |       |       |    diff = gz * uc1 - ax * uc2              |
|   833 |        |       |       |                                            |
|   834 |        |       |       |    # om = i * diff = (-Im(diff), Re(diff)) |
|   835 |        |       |       |    diff_r = diff.real                      |
|   836 |        |       |       |    diff_i = diff.imag                      |
|   837 |        |       |       |                                            |
|   838 |        |       |       |    om_r = -diff_i                          |
|   839 |        |       |       |    om_i = diff_r                           |
|   840 |        |       |       |                                            |
|   841 |        |       |       |    S.om2[...] = xp.asarray(om_r + 1j * om_ |
|   842 |        |       |       |                                            |
|   843 |        |       |       |                                            |
|   844 |        |       |       |# ----------------------------------------- |
|   845 |        |       |       |# STEP2B â€” build uiuj and forward FFT (dn |
|   846 |        |       |       |# ----------------------------------------- |
|   847 |        |       |       |def dns_step2b(S: DnsState) -> None:        |
|   848 |        |       |       |    """                                     |
|   849 |        |       |       |    Python/CuPy port of dnsCudaStep2B(DnsDe |
|   850 |        |       |       |                                            |
|   851 |        |       |       |    Mirrors Fortran STEP2B:                 |
|   852 |        |       |       |                                            |
|   853 |        |       |       |      1) Build uiuj in UR(x,z,1..3) on the  |
|   854 |        |       |       |      2) Full-grid forward FFT: UR_full â†’ |
|   855 |        |       |       |         (VRFFTF + VCFFTF in Fortran)       |
|   856 |        |       |       |      3) Zero UC(X,NZ+1,I) for X<=NX/2, I=1 |
|   857 |        |       |       |    """                                     |
|   858 |        |       |       |    xp = S.xp                               |
|   859 |        |       |       |                                            |
|   860 |        |       |       |    # Geometry on the full 3/2 grid         |
|   861 |        |       |       |    N = S.Nbase          # NX = NZ = Nbase  |
|   862 |        |       |       |    NX_full = S.NX_full        # 3*N/2      |
|   863 |        |       |       |    NZ_full = S.NZ_full        # 3*N/2      |
|   864 |        |       |       |    NK_full = S.NK_full        # 3*N/4+1    |
|   865 |        |       |       |                                            |
|   866 |        |       |       |    UR = S.ur_full                          |
|   867 |        |       |       |    UC = S.uc_full                          |
|   868 |        |       |       |                                            |
|   869 |        |       |       |    u = UR[0]   # (NZ_full, NX_full)        |
|   870 |        |       |       |    w = UR[1]   # (NZ_full, NX_full)        |
|   871 |        |       |       |                                            |
|   872 |        |       |       |    # Use in-place multiplies to avoid temp |
|   873 |        |       |       |    xp.multiply(u, w, out=UR[2])  # u * w   |
|   874 |        |       |       |    xp.multiply(u, u, out=UR[0])  # u^2     |
|   875 |        |       |       |    xp.multiply(w, w, out=UR[1])  # w^2     |
|   876 |        |       |       |                                            |
|   877 |        |       |       |    vfft_full_forward_ur_full_to_uc_full(S) |
|   878 |        |       |       |                                            |
|   879 |        |       |       |    NX_half = N // 2                        |
|   880 |        |       |       |    NZ = N                                  |
|   881 |        |       |       |    z_mid = NZ                              |
|   882 |        |       |       |                                            |
|   883 |        |       |       |    kx_max = min(NX_half, NK_full)          |
|   884 |        |       |       |                                            |
|   885 |        |       |       |    if z_mid < NZ_full and kx_max > 0:      |
|   886 |        |       |       |        UC[0:3, z_mid, 0:kx_max] = xp.compl |
|   887 |        |       |       |                                            |
|   888 |        |       |       |                                            |
|   889 |        |       |       |# ----------------------------------------- |
|   890 |        |       |       |# STEP3 â€” vorticity update using om2 & fn |
|   891 |        |       |       |# ----------------------------------------- |
|   892 |        |       |       |def dns_step3(S: DnsState) -> None:         |
|   893 |        |       |       |    xp = S.xp                               |
|   894 |        |       |       |                                            |
|   895 |        |       |       |    om2 = S.om2                             |
|   896 |        |       |       |    fnm1 = S.fnm1                           |
|   897 |        |       |       |    alfa = S.alfa                           |
|   898 |        |       |       |    gamma = S.gamma                         |
|   899 |        |       |       |    uc_full = S.uc_full                     |
|   900 |        |       |       |                                            |
|   901 |        |       |       |    Nbase = int(S.Nbase)                    |
|   902 |        |       |       |    NX_half = Nbase // 2                    |
|   903 |        |       |       |    NZ = Nbase                              |
|   904 |        |       |       |                                            |
|   905 |        |       |       |    visc = xp.float32(S.visc)               |
|   906 |        |       |       |    dt = xp.float32(S.dt)                   |
|   907 |        |       |       |    cn = xp.float32(S.cn)                   |
|   908 |        |       |       |    cnm1 = xp.float32(S.cnm1)               |
|   909 |        |       |       |                                            |
|   910 |        |       |       |    z_spec = S.step3_z_spec                 |
|   911 |        |       |       |    divxz = S.step3_divxz                   |
|   912 |        |       |       |    GA = S.step3_GA                         |
|   913 |        |       |       |    G2mA2 = S.step3_G2mA2                   |
|   914 |        |       |       |    K2 = S.step3_K2                         |
|   915 |        |       |       |                                            |
|   916 |        |       |       |    uc0_low = uc_full[0, :, :NX_half]       |
|   917 |        |       |       |    uc1_low = uc_full[1, :, :NX_half]       |
|   918 |        |       |       |    uc2_low = uc_full[2, :, :NX_half]       |
|   919 |        |       |       |                                            |
|   920 |        |       |       |    uc1_th = S.step3_uc1_th                 |
|   921 |        |       |       |    uc2_th = S.step3_uc2_th                 |
|   922 |        |       |       |    uc3_th = S.step3_uc3_th                 |
|   923 |        |       |       |    xp.take(uc0_low, z_spec, axis=0, out=uc |
|   924 |        |       |       |    xp.take(uc1_low, z_spec, axis=0, out=uc |
|   925 |        |       |       |    xp.take(uc2_low, z_spec, axis=0, out=uc |
|   926 |        |       |       |                                            |
|   927 |        |       |       |    tmp_FN = S.scratch1                     |
|   928 |        |       |       |    tmp_c = S.scratch2                      |
|   929 |        |       |       |    xp.subtract(uc1_th, uc2_th, out=tmp_FN) |
|   930 |        |    1% |       |    xp.multiply(tmp_FN, GA, out=tmp_FN)     |
|   931 |        |       |       |    xp.multiply(uc3_th, G2mA2, out=tmp_c)   |
|   932 |        |       |       |    xp.add(tmp_FN, tmp_c, out=tmp_FN)       |
|   933 |        |       |       |    tmp_FN *= divxz                         |
|   934 |        |       |       |                                            |
|   935 |        |       |       |    VT = xp.float32(0.5) * visc * dt        |
|   936 |        |       |       |    ARG = S.step3_ARG                       |
|   937 |        |       |       |    DEN = S.step3_DEN                       |
|   938 |        |       |       |    xp.multiply(K2, VT, out=ARG)            |
|   939 |        |       |       |    xp.add(ARG, xp.float32(1.0), out=DEN)   |
|   940 |        |       |       |                                            |
|   941 |        |       |       |    c2 = xp.float32(0.5) * dt * (xp.float32 |
|   942 |        |       |       |    c3 = -xp.float32(0.5) * dt * cnm1       |
|   943 |        |       |       |                                            |
|   944 |        |       |       |    NUM = S.step3_NUM                       |
|   945 |        |       |       |    NUM[...] = om2                          |
|   946 |        |       |       |    xp.multiply(om2, ARG, out=tmp_c)        |
|   947 |        |       |       |    NUM -= tmp_c                            |
|   948 |        |       |       |                                            |
|   949 |        |       |       |    xp.multiply(tmp_FN, c2, out=tmp_c)      |
|   950 |        |       |       |    NUM += tmp_c                            |
|   951 |        |       |       |    xp.multiply(fnm1, c3, out=tmp_c)        |
|   952 |        |       |       |    NUM += tmp_c                            |
|   953 |        |       |       |                                            |
|   954 |        |       |       |    xp.divide(NUM, DEN, out=om2)            |
|   955 |        |       |       |                                            |
|   956 |        |       |       |    fnm1[...] = tmp_FN                      |
|   957 |        |       |       |                                            |
|   958 |        |       |       |    out1 = S.scratch1                       |
|   959 |        |       |       |    out2 = S.scratch2                       |
|   960 |        |       |       |    out1[...] = 0                           |
|   961 |        |       |       |    out2[...] = 0                           |
|   962 |        |       |       |                                            |
|   963 |        |       |       |    if NX_half > 1:                         |
|   964 |        |       |       |        invK2_sub = S.step3_invK2_sub       |
|   965 |        |       |       |                                            |
|   966 |        |       |       |        out1[:, 1:] = om2[:, 1:]            |
|   967 |        |       |       |        out1[:, 1:] *= invK2_sub            |
|   968 |        |       |       |        out1[:, 1:] *= gamma[:, None]       |
|   969 |        |    2% |       |        out1[:, 1:] *= xp.complex64(-1.0j)  |
|   970 |        |       |       |                                            |
|   971 |        |       |       |        out2[:, 1:] = om2[:, 1:]            |
|   972 |        |       |       |        out2[:, 1:] *= invK2_sub            |
|   973 |        |       |       |        out2[:, 1:] *= alfa[1:][None, :]    |
|   974 |        |    1% |       |        out2[:, 1:] *= xp.complex64(1.0j)   |
|   975 |        |       |       |                                            |
|   976 |        |       |       |    out1[:, 0] = 0                          |
|   977 |        |       |       |    mask0 = S.step3_mask_ix0                |
|   978 |    6%  |   24% |   3%  |    out1[mask0, 0] = xp.complex64(-1.0j) *  |
|   979 |        |       |       |                                            |
|   980 |        |       |       |    uc_full[0, :NZ, :NX_half] = out1        |
|   981 |        |       |       |    uc_full[1, :NZ, :NX_half] = out2        |
|   982 |        |       |       |                                            |
|   983 |        |       |       |    S.cnm1 = float(cn)                      |
|   984 |        |       |       |                                            |
|   985 |        |       |       |                                            |
|   986 |        |       |       |# ========================================= |
|   987 |        |       |       |# STEP2A core (dealias + reshuffle + invers |
|   988 |        |       |       |# ========================================= |
|   989 |        |       |       |def dns_step2a(S: DnsState) -> None:        |
|   990 |        |       |       |    xp = S.xp                               |
|   991 |        |       |       |    N = S.Nbase                             |
|   992 |        |       |       |    NX = S.NX                               |
|   993 |        |       |       |    NZ = S.NZ                               |
|   994 |        |       |       |    NX_full = S.NX_full                     |
|   995 |        |       |       |    NZ_full = S.NZ_full                     |
|   996 |        |       |       |    NK_full = S.NK_full                     |
|   997 |        |       |       |                                            |
|   998 |        |       |       |    UC = S.uc_full                          |
|   999 |        |       |       |                                            |
|  1000 |        |       |       |    hi_start = N // 2                       |
|  1001 |        |       |       |    hi_end = min(3 * N // 4, NK_full - 1)   |
|  1002 |        |       |       |    if hi_start <= hi_end:                  |
|  1003 |        |       |       |        UC[0:2, :, hi_start:hi_end + 1] = x |
|  1004 |        |       |       |                                            |
|  1005 |        |       |       |    halfN = N // 2                          |
|  1006 |        |       |       |    k_max = min(halfN, NK_full)             |
|  1007 |        |       |       |    if k_max > 0:                           |
|  1008 |        |       |       |        z_mid_start = halfN                 |
|  1009 |        |       |       |        z_mid_end = N                       |
|  1010 |        |       |       |        z_top_start = N                     |
|  1011 |        |       |       |        z_top_end = N + halfN               |
|  1012 |        |       |       |        UC[0:2, z_top_start:z_top_end, :k_m |
|  1013 |        |       |       |        UC[0:2, z_mid_start:z_mid_end, :k_m |
|  1014 |        |       |       |                                            |
|  1015 |        |       |       |    fft = S.fft                             |
|  1016 |        |       |       |    if fft is None:                         |
|  1017 |        |       |       |        raise RuntimeError("scipy.fft is no |
|  1018 |        |       |       |                                            |
|  1019 |        |       |       |    UC01 = UC[0:2, :, :]                    |
|  1020 |        |       |       |                                            |
|  1021 |        |       |       |    if S.backend == "cpu":                  |
|  1022 |        |       |       |        ur01 = fft.irfft2(UC01, s=(NZ_full, |
|  1023 |        |       |       |    else:                                   |
|  1024 |        |       |       |        plan = S.fft_plan_irfft2_uc01       |
|  1025 |        |       |       |        if plan is not None:                |
|  1026 |        |       |       |            with plan:                      |
|  1027 |        |    2% |       |                ur01 = fft.irfft2(UC01, s=( |
|  1028 |        |       |       |        else:                               |
|  1029 |        |       |       |            ur01 = fft.irfft2(UC01, s=(NZ_f |
|  1030 |        |       |       |                                            |
|  1031 |        |       |       |    ur01 *= xp.float32(NZ_full * NX_full)   |
|  1032 |        |       |       |                                            |
|  1033 |        |       |       |    S.ur_full[0:2, :, :] = ur01             |
|  1034 |        |       |       |    S.ur_full[2, :, :] = xp.float32(0.0)    |
|  1035 |        |       |       |                                            |
|  1036 |        |       |       |    off_x = (NX_full - NX) // 2             |
|  1037 |        |       |       |    off_z = (NZ_full - NZ) // 2             |
|  1038 |        |       |       |                                            |
|  1039 |        |       |       |    S.ur[:, :, 0] = S.ur_full[0, off_z:off_ |
|  1040 |        |       |       |    S.ur[:, :, 1] = S.ur_full[1, off_z:off_ |
|  1041 |        |       |       |    S.ur[:, :, 2] = 0.0                     |
|  1042 |        |       |       |                                            |
|  1043 |        |       |       |                                            |
|  1044 |        |       |       |# ----------------------------------------- |
|  1045 |        |       |       |# NEXTDT â€” CFL based timestep             |
|  1046 |        |       |       |# ----------------------------------------- |
|  1047 |        |       |       |                                            |
|  1048 |        |       |       |def compute_cflm(S: DnsState):              |
|  1049 |        |       |       |    xp = S.xp                               |
|  1050 |        |       |       |                                            |
|  1051 |        |       |       |    NX3D2 = S.NX_full                       |
|  1052 |        |       |       |    NZ3D2 = S.NZ_full                       |
|  1053 |        |       |       |                                            |
|  1054 |        |       |       |    u = S.ur_full[0, :NZ3D2, :NX3D2]        |
|  1055 |        |       |       |    w = S.ur_full[1, :NZ3D2, :NX3D2]        |
|  1056 |        |       |       |                                            |
|  1057 |        |       |       |    tmp = S.cfl_tmp[:NZ3D2, :NX3D2]         |
|  1058 |        |       |       |    absw = S.cfl_absw[:NZ3D2, :NX3D2]       |
|  1059 |        |       |       |                                            |
|  1060 |        |       |       |    xp.abs(u, out=tmp)                      |
|  1061 |        |       |       |    xp.abs(w, out=absw)                     |
|  1062 |        |       |       |    xp.add(tmp, absw, out=tmp)              |
|  1063 |        |       |       |                                            |
|  1064 |        |       |       |    CFLM = xp.max(tmp) * S.inv_dx           |
|  1065 |        |       |       |    if S.backend == "cpu":                  |
|  1066 |        |       |       |        return float(CFLM)                  |
|  1067 |        |       |       |                                            |
|  1068 |        |       |       |    return CFLM                             |
|  1069 |        |       |       |                                            |
|  1070 |        |       |       |                                            |
|  1071 |        |       |       |def next_dt(S: DnsState) -> None:           |
|  1072 |        |       |       |    PI = math.pi                            |
|  1073 |        |       |       |    CFLM = compute_cflm(S)                  |
|  1074 |        |       |       |                                            |
|  1075 |        |       |       |    if S.backend == "gpu":                  |
|  1076 |    4%  |   19% |   3%  |        CFLM = float(CFLM)  # one sync here |
|  1077 |        |       |       |                                            |
|  1078 |        |       |       |    if CFLM <= 0.0 or S.dt <= 0.0:          |
|  1079 |        |       |       |        return                              |
|  1080 |        |       |       |                                            |
|  1081 |        |       |       |    CFL = CFLM * S.dt * PI                  |
|  1082 |        |       |       |    S.cn = 0.8 + 0.2 * (S.cflnum / CFL)     |
|  1083 |        |       |       |    S.dt = S.dt * S.cn                      |
|  1084 |        |       |       |                                            |
|  1085 |        |       |       |                                            |
|  1086 |        |       |       |# ========================================= |
|  1087 |        |       |       |# Python equivalent of dnsCudaDumpFieldAsPG |
|  1088 |        |       |       |# ========================================= |
|  1089 |        |       |       |def dump_field_as_pgm_full(S: DnsState, com |
|  1090 |        |       |       |    NX_full = S.NX_full                     |
|  1091 |        |       |       |    NZ_full = S.NZ_full                     |
|  1092 |        |       |       |                                            |
|  1093 |        |       |       |    if S.backend == "gpu":                  |
|  1094 |        |       |       |        ur_full_host = _np.asarray(S.ur_ful |
|  1095 |        |       |       |    else:                                   |
|  1096 |        |       |       |        ur_full_host = _np.asarray(S.ur_ful |
|  1097 |        |       |       |                                            |
|  1098 |        |       |       |    field = ur_full_host[comp, :, :]        |
|  1099 |        |       |       |                                            |
|  1100 |        |       |       |    minv = float(field.min())               |
|  1101 |        |       |       |    maxv = float(field.max())               |
|  1102 |        |       |       |                                            |
|  1103 |        |       |       |    try:                                    |
|  1104 |        |       |       |        f = open(filename, "wb")            |
|  1105 |        |       |       |    except OSError as e:                    |
|  1106 |        |       |       |        print(f"[DUMP] fopen failed for {fi |
|  1107 |        |       |       |        return                              |
|  1108 |        |       |       |                                            |
|  1109 |        |       |       |    header = f"P5\n{NX_full} {NZ_full}\n255 |
|  1110 |        |       |       |    f.write(header.encode("ascii"))         |
|  1111 |        |       |       |                                            |
|  1112 |        |       |       |    rng = maxv - minv                       |
|  1113 |        |       |       |                                            |
|  1114 |        |       |       |    if abs(rng) <= 1.0e-12:                 |
|  1115 |        |       |       |        c = bytes([128])                    |
|  1116 |        |       |       |        row = c * NX_full                   |
|  1117 |        |       |       |        for _ in range(NZ_full):            |
|  1118 |        |       |       |            f.write(row)                    |
|  1119 |        |       |       |    else:                                   |
|  1120 |        |       |       |        for j in range(NZ_full):            |
|  1121 |        |       |       |            for i in range(NX_full):        |
|  1122 |        |       |       |                val = float(field[j, i])    |
|  1123 |        |       |       |                norm = (val - minv) / rng   |
|  1124 |        |       |       |                pixf = 1.0 + norm * 254.0   |
|  1125 |        |       |       |                pix = int(pixf + 0.5)       |
|  1126 |        |       |       |                if pix < 1:                 |
|  1127 |        |       |       |                    pix = 1                 |
|  1128 |        |       |       |                if pix > 255:               |
|  1129 |        |       |       |                    pix = 255               |
|  1130 |        |       |       |                f.write(bytes([pix]))       |
|  1131 |        |       |       |                                            |
|  1132 |        |       |       |    f.close()                               |
|  1133 |        |       |       |    print(f"[DUMP] Wrote {filename} (PGM, { |
|  1134 |        |       |       |          f"comp={comp}, min={minv:g}, max= |
|  1135 |        |       |       |                                            |
|  1136 |        |       |       |                                            |
|  1137 |        |       |       |# ----------------------------------------- |
|  1138 |        |       |       |# Helpers for visualization fields (energy, |
|  1139 |        |       |       |# ----------------------------------------- |
|  1140 |        |       |       |                                            |
|  1141 |        |       |       |def dns_kinetic(S: DnsState) -> None:       |
|  1142 |        |       |       |    xp = S.xp                               |
|  1143 |        |       |       |                                            |
|  1144 |        |       |       |    u = S.ur_full[0, :, :]                  |
|  1145 |        |       |       |    w = S.ur_full[1, :, :]                  |
|  1146 |        |       |       |                                            |
|  1147 |        |       |       |    ke = xp.sqrt(u * u + w * w)             |
|  1148 |        |       |       |    S.ur_full[2, :, :] = ke.astype(xp.float |
|  1149 |        |       |       |                                            |
|  1150 |        |       |       |                                            |
|  1151 |        |       |       |def _spectral_band_to_phys_full_grid(S: Dns |
|  1152 |        |       |       |    xp = S.xp                               |
|  1153 |        |       |       |                                            |
|  1154 |        |       |       |    N = S.Nbase                             |
|  1155 |        |       |       |    NX_full = S.NX_full                     |
|  1156 |        |       |       |    NZ_full = S.NZ_full                     |
|  1157 |        |       |       |    NK_full = S.NK_full                     |
|  1158 |        |       |       |                                            |
|  1159 |        |       |       |    NX_half = N // 2                        |
|  1160 |        |       |       |    NZ = N                                  |
|  1161 |        |       |       |                                            |
|  1162 |        |       |       |    uc_tmp = xp.zeros((NZ_full, NK_full), d |
|  1163 |        |       |       |    uc_tmp[:NZ, :NX_half] = band            |
|  1164 |        |       |       |                                            |
|  1165 |        |       |       |    hi_start = N // 2                       |
|  1166 |        |       |       |    hi_end = min(3 * N // 4, NK_full - 1)   |
|  1167 |        |       |       |    if hi_start <= hi_end:                  |
|  1168 |        |       |       |        uc_tmp[:, hi_start:hi_end + 1] = xp |
|  1169 |        |       |       |                                            |
|  1170 |        |       |       |    halfN = N // 2                          |
|  1171 |        |       |       |    k_max = min(halfN, NK_full)             |
|  1172 |        |       |       |                                            |
|  1173 |        |       |       |    if k_max > 0:                           |
|  1174 |        |       |       |        z_mid_start = halfN                 |
|  1175 |        |       |       |        z_mid_end = halfN + halfN           |
|  1176 |        |       |       |        z_top_start = N                     |
|  1177 |        |       |       |        z_top_end = N + halfN               |
|  1178 |        |       |       |                                            |
|  1179 |        |       |       |        uc_tmp[z_top_start:z_top_end, :k_ma |
|  1180 |        |       |       |        uc_tmp[z_mid_start:z_mid_end, :k_ma |
|  1181 |        |       |       |                                            |
|  1182 |        |       |       |    z_mid = NZ                              |
|  1183 |        |       |       |    if z_mid < NZ_full:                     |
|  1184 |        |       |       |        uc_tmp[z_mid, :NX_half] = xp.comple |
|  1185 |        |       |       |                                            |
|  1186 |        |       |       |    fft = S.fft                             |
|  1187 |        |       |       |    if fft is None:                         |
|  1188 |        |       |       |        raise RuntimeError("scipy.fft is no |
|  1189 |        |       |       |                                            |
|  1190 |        |       |       |    if S.backend == "cpu":                  |
|  1191 |        |       |       |        phys = fft.irfft2(uc_tmp, s=(NZ_ful |
|  1192 |        |       |       |    else:                                   |
|  1193 |        |       |       |        phys = fft.irfft2(uc_tmp, s=(NZ_ful |
|  1194 |        |       |       |                                            |
|  1195 |        |       |       |    phys *= (NZ_full * NX_full)             |
|  1196 |        |       |       |    return xp.asarray(phys, dtype=xp.float3 |
|  1197 |        |       |       |                                            |
|  1198 |        |       |       |                                            |
|  1199 |        |       |       |def dns_om2_phys(S: DnsState) -> None:      |
|  1200 |        |       |       |    band = S.om2                            |
|  1201 |        |       |       |    phys = _spectral_band_to_phys_full_grid |
|  1202 |        |       |       |    S.ur_full[2, :, :] = phys               |
|  1203 |        |       |       |                                            |
|  1204 |        |       |       |                                            |
|  1205 |        |       |       |def dns_stream_func(S: DnsState) -> None:   |
|  1206 |        |       |       |    xp = S.xp                               |
|  1207 |        |       |       |                                            |
|  1208 |        |       |       |    N = S.Nbase                             |
|  1209 |        |       |       |    NX_half = N // 2                        |
|  1210 |        |       |       |    NZ = N                                  |
|  1211 |        |       |       |                                            |
|  1212 |        |       |       |    alfa_1d = S.alfa.astype(xp.float32)     |
|  1213 |        |       |       |    gamma_1d = S.gamma.astype(xp.float32)   |
|  1214 |        |       |       |                                            |
|  1215 |        |       |       |    ax = alfa_1d[None, :]                   |
|  1216 |        |       |       |    gz = gamma_1d[:, None]                  |
|  1217 |        |       |       |                                            |
|  1218 |        |       |       |    K2 = ax * ax + gz * gz                  |
|  1219 |        |       |       |    K2 = K2 + xp.float32(1.0e-30)           |
|  1220 |        |       |       |                                            |
|  1221 |        |       |       |    phi_hat = S.om2 / K2                    |
|  1222 |        |       |       |    phys = _spectral_band_to_phys_full_grid |
|  1223 |        |       |       |    S.ur_full[2, :, :] = phys               |
|  1224 |        |       |       |                                            |
|  1225 |        |       |       |                                            |
|  1226 |        |       |       |# ----------------------------------------- |
|  1227 |        |       |       |# Main driver (Python version of main in dn |
|  1228 |        |       |       |# ----------------------------------------- |
|  1229 |        |       |       |def run_dns(                                |
|  1230 |        |       |       |    N: int = 8,                             |
|  1231 |        |       |       |    Re: float = 100,                        |
|  1232 |        |       |       |    K0: float = 10.0,                       |
|  1233 |        |       |       |    STEPS: int = 2,                         |
|  1234 |        |       |       |    CFL: float = 0.75,                      |
|  1235 |        |       |       |    backend: Literal["cpu", "gpu", "auto"]  |
|  1236 |        |       |       |) -> None:                                  |
|  1237 |        |       |       |    print("--- RUN DNS ---")                |
|  1238 |        |       |       |    print(f" N   = {N}")                    |
|  1239 |        |       |       |    print(f" Re  = {Re}")                   |
|  1240 |        |       |       |    print(f" K0  = {K0}")                   |
|  1241 |        |       |       |    print(f" Steps = {STEPS}")              |
|  1242 |        |       |       |    print(f" CFL  = {CFL}")                 |
|  1243 |        |       |       |    print(f" requested = {backend}")        |
|  1244 |        |       |       |                                            |
|  1245 |        |       |       |    S = create_dns_state(N=N, Re=Re, K0=K0, |
|  1246 |        |       |       |    print(f" effective = {S.backend} (xp =  |
|  1247 |        |       |       |                                            |
|  1248 |        |       |       |    if S.backend == "cpu" and _spfft is not |
|  1249 |        |       |       |        fft_ctx = _spfft.set_workers(S.fft_ |
|  1250 |        |       |       |    else:                                   |
|  1251 |        |       |       |        fft_ctx = nullcontext()             |
|  1252 |        |       |       |                                            |
|  1253 |        |       |       |    with fft_ctx:                           |
|  1254 |        |       |       |        if _spfft is not None:              |
|  1255 |        |       |       |            print(f" scipy.fft workers in-c |
|  1256 |        |       |       |        else:                               |
|  1257 |        |       |       |            print(" scipy.fft workers in-co |
|  1258 |        |       |       |                                            |
|  1259 |        |       |       |        dns_step2a(S)                       |
|  1260 |        |       |       |                                            |
|  1261 |        |       |       |        CFLM = compute_cflm(S)              |
|  1262 |        |       |       |        if S.backend == "gpu":              |
|  1263 |        |       |       |            CFLM0 = float(CFLM)  # one sync |
|  1264 |        |       |       |        else:                               |
|  1265 |        |       |       |            CFLM0 = CFLM                    |
|  1266 |        |       |       |                                            |
|  1267 |        |       |       |        S.dt = S.cflnum / (CFLM0 * math.pi) |
|  1268 |        |       |       |        S.cn = 1.0                          |
|  1269 |        |       |       |        S.cnm1 = 0.0                        |
|  1270 |        |       |       |        S.t = 0.0                           |
|  1271 |        |       |       |                                            |
|  1272 |        |       |       |        print(f" [NEXTDT INIT] CFLM={CFLM:1 |
|  1273 |        |       |       |        print(f" Initial DT={S.dt:11.7f} CN |
|  1274 |        |       |       |                                            |
|  1275 |        |       |       |        S.sync()                            |
|  1276 |        |       |       |        t0 = time.perf_counter()            |
|  1277 |        |       |       |                                            |
|  1278 |        |       |       |        for it in range(1, STEPS + 1):      |
|  1279 |        |       |       |            S.it = it                       |
|  1280 |        |       |       |                                            |
|  1281 |        |       |       |            dt_old = S.dt                   |
|  1282 |        |       |       |                                            |
|  1283 |        |       |       |            dns_step2b(S)                   |
|  1284 |        |       |       |            dns_step3(S)                    |
|  1285 |        |       |       |            dns_step2a(S)                   |
|  1286 |        |       |       |                                            |
|  1287 |        |       |       |            next_dt(S)                      |
|  1288 |        |       |       |            S.t += dt_old                   |
|  1289 |        |       |       |                                            |
|  1290 |        |       |       |            if (it % 100) == 0 or it == 1 o |
|  1291 |        |       |       |                print(f" ITERATION {it:6d}  |
|  1292 |        |       |       |                                            |
|  1293 |        |       |       |        S.sync()                            |
|  1294 |        |       |       |        t1 = time.perf_counter()            |
|  1295 |        |       |       |                                            |
|  1296 |        |       |       |        elap = t1 - t0                      |
|  1297 |        |       |       |        fps = (STEPS / elap) if elap > 0 el |
|  1298 |        |       |       |                                            |
|  1299 |        |       |       |        print(f" Elapsed CPU time for {STEP |
|  1300 |        |       |       |        print(f" Final T={S.t:8g}  CN={S.cn |
|  1301 |        |       |       |        print(f" FPS = {fps:7g}")           |
|  1302 |        |       |       |                                            |
|  1303 |        |       |       |def main():                                 |
|  1304 |        |       |       |    args = sys.argv[1:]                     |
|  1305 |        |       |       |    N = int(args[0]) if len(args) > 0 else  |
|  1306 |        |       |       |    Re = float(args[1]) if len(args) > 1 el |
|  1307 |        |       |       |    K0 = float(args[2]) if len(args) > 2 el |
|  1308 |        |       |       |    STEPS = int(args[3]) if len(args) > 3 e |
|  1309 |        |       |       |    CFL = float(args[4]) if len(args) > 4 e |
|  1310 |        |       |       |                                            |
|  1311 |        |       |       |    BACK = args[5].lower() if len(args) > 5 |
|  1312 |        |       |       |    if BACK not in ("cpu", "gpu", "auto"):  |
|  1313 |        |       |       |        BACK = "auto"                       |
|  1314 |        |       |       |                                            |
|  1315 |        |       |       |    run_dns(N=N, Re=Re, K0=K0, STEPS=STEPS, |
|  1316 |        |       |       |                                            |
|  1317 |        |       |       |                                            |
|  1318 |        |       |       |if __name__ == "__main__":                  |
|  1319 |        |       |       |    main()                                  |
|       |        |       |       |                                            |
|-------+--------+-------+-------+--------------------------------------------|
|       |        |       |       |function summary for C:\Users\tobbe\python
 |
|    79 |        |       |       |frand                                       |
|   466 |    2%  |   13% |       |dns_pao_host_init                           |
|   523 |        |       |       |dns_pao_host_init.<locals>.random_from_vec  |
|   759 |        |       |       |vfft_full_forward_ur_full_to_uc_full        |
|   847 |        |    2% |       |dns_step2b                                  |
|   892 |    8%  |   33% |   5%  |dns_step3                                   |
|   989 |    1%  |    4% |       |dns_step2a                                  |
|  1048 |        |       |       |compute_cflm                                |
|  1071 |    5%  |   19% |   3%  |next_dt                                     |
+-----------------------------------------------------------------------------+
